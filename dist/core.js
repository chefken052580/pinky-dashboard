/* Core JS Bundle - Generated by BundleOptimizer */

/* loading-manager.js */
class LoadingManager {
constructor() {
this.activeRequests = new Map();
this.requestCounter = 0;
this.initStyles();
this.initToastContainer();
}
initStyles() {
if (document.getElementById('loading-manager-styles')) return;
const style = document.createElement('style');
style.id = 'loading-manager-styles';
style.textContent = `
.loading-overlay {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(26, 26, 46, 0.9);
display: flex;
align-items: center;
justify-content: center;
z-index: 9999;
backdrop-filter: blur(4px);
}
.loading-spinner {
width: 60px;
height: 60px;
border: 4px solid rgba(102, 126, 234, 0.3);
border-top: 4px solid #00d4ff;
border-radius: 50%;
animation: spin 1s linear infinite;
}
.loading-message {
position: absolute;
top: 60%;
color: #00d4ff;
font-size: 14px;
font-weight: 500;
text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}
@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}
.toast-container {
position: fixed;
top: 80px;
right: 20px;
z-index: 10000;
max-width: 400px;
}
.toast {
background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
border: 1px solid;
border-radius: 8px;
padding: 16px 20px;
margin-bottom: 12px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
animation: slideIn 0.3s ease-out;
display: flex;
align-items: flex-start;
gap: 12px;
}
.toast-error {
border-color: #e74c3c;
}
.toast-success {
border-color: #2ecc71;
}
.toast-warning {
border-color: #f39c12;
}
.toast-info {
border-color: #00d4ff;
}
.toast-icon {
font-size: 20px;
flex-shrink: 0;
}
.toast-content {
flex: 1;
}
.toast-title {
font-weight: 600;
margin-bottom: 4px;
font-size: 14px;
}
.toast-message {
font-size: 13px;
color: #aaa;
line-height: 1.4;
}
.toast-close {
background: none;
border: none;
color: #aaa;
cursor: pointer;
font-size: 18px;
padding: 0;
width: 20px;
height: 20px;
flex-shrink: 0;
}
.toast-close:hover {
color: #00d4ff;
}
@keyframes slideIn {
from {
transform: translateX(400px);
opacity: 0;
}
to {
transform: translateX(0);
opacity: 1;
}
}
@keyframes slideOut {
from {
transform: translateX(0);
opacity: 1;
}
to {
transform: translateX(400px);
opacity: 0;
}
}
.toast.removing {
animation: slideOut 0.3s ease-in forwards;
}
.inline-loader {
display: inline-block;
width: 16px;
height: 16px;
border: 2px solid rgba(102, 126, 234, 0.3);
border-top: 2px solid #00d4ff;
border-radius: 50%;
animation: spin 0.8s linear infinite;
vertical-align: middle;
margin-left: 8px;
}
.widget-loading {
position: relative;
opacity: 0.6;
pointer-events: none;
}
.widget-loading::after {
content: "";
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 24px;
height: 24px;
border: 3px solid rgba(102, 126, 234, 0.3);
border-top: 3px solid #00d4ff;
border-radius: 50%;
animation: spin 0.8s linear infinite;
}
`;
document.head.appendChild(style);
}
initToastContainer() {
if (document.querySelector('.toast-container')) return;
const container = document.createElement('div');
container.className = 'toast-container';
container.id = 'toast-container';
document.body.appendChild(container);
}
showLoading(message = 'Loading...') {
const overlay = document.createElement('div');
overlay.className = 'loading-overlay';
overlay.id = 'global-loading-overlay';
overlay.innerHTML = `
<div>
<div class="loading-spinner"></div>
<div class="loading-message">${message}</div>
</div>
`;
document.body.appendChild(overlay);
return overlay;
}
hideLoading() {
const overlay = document.getElementById('global-loading-overlay');
if (overlay) {
overlay.remove();
}
}
showWidgetLoading(element) {
if (element && !element.classList.contains('widget-loading')) {
element.classList.add('widget-loading');
}
}
hideWidgetLoading(element) {
if (element) {
element.classList.remove('widget-loading');
}
}
showToast(type, title, message, duration = 5000) {
const container = document.getElementById('toast-container');
if (!container) return;
const icons = {
error: '‚ùå',
success: '‚úÖ',
warning: '‚ö†Ô∏è',
info: '‚ÑπÔ∏è'
};
const toast = document.createElement('div');
toast.className = `toast toast-${type}`;
toast.innerHTML = `
<div class="toast-icon">${icons[type]}</div>
<div class="toast-content">
<div class="toast-title">${title}</div>
<div class="toast-message">${message}</div>
</div>
<button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
`;
container.appendChild(toast);
if (duration > 0) {
setTimeout(() => {
toast.classList.add('removing');
setTimeout(() => toast.remove(), 300);
}, duration);
}
return toast;
}
error(title, message) {
return this.showToast('error', title, message, 8000);
}
success(title, message) {
return this.showToast('success', title, message, 4000);
}
warning(title, message) {
return this.showToast('warning', title, message, 6000);
}
info(title, message) {
return this.showToast('info', title, message, 5000);
}
async fetch(url, options = {}, config = {}) {
const {
loadingMessage = 'Loading...',
errorTitle = 'Request Failed',
showGlobalLoader = false,
widgetElement = null,
silent = false,
retries = 1,
timeout = 30000
} = config;
const requestId = ++this.requestCounter;
try {
if (showGlobalLoader) {
this.showLoading(loadingMessage);
}
if (widgetElement) {
this.showWidgetLoading(widgetElement);
}
this.activeRequests.set(requestId, { url, startTime: Date.now() });
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), timeout);
const fetchOptions = {
...options,
signal: controller.signal
};
let lastError;
let attempt = 0;
while (attempt <= retries) {
try {
const response = await fetch(url, fetchOptions);
clearTimeout(timeoutId);
if (!response.ok) {
const errorText = await response.text().catch(() => 'Unknown error');
throw new Error(`HTTP ${response.status}: ${errorText}`);
}
const contentType = response.headers.get('content-type');
let data;
if (contentType && contentType.includes('application/json')) {
data = await response.json();
} else {
data = await response.text();
}
this.activeRequests.delete(requestId);
return { success: true, data, response };
} catch (err) {
lastError = err;
attempt++;
if (attempt <= retries) {
await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
}
}
}
throw lastError;
} catch (error) {
this.activeRequests.delete(requestId);
let friendlyMessage = error.message;
if (error.name === 'AbortError') {
friendlyMessage = 'Request timed out. Please check your connection and try again.';
} else if (error.message.includes('Failed to fetch')) {
friendlyMessage = 'Unable to reach server. Please check your internet connection.';
} else if (error.message.includes('NetworkError')) {
friendlyMessage = 'Network error occurred. Please try again.';
} else if (error.message.includes('HTTP 404')) {
friendlyMessage = 'Resource not found. The requested data may no longer exist.';
} else if (error.message.includes('HTTP 500')) {
friendlyMessage = 'Server error. Please try again in a few moments.';
} else if (error.message.includes('HTTP 401') || error.message.includes('HTTP 403')) {
friendlyMessage = 'Authentication failed. Please check your credentials.';
}
if (!silent) {
this.error(errorTitle, friendlyMessage);
}
console.error('[LoadingManager] Fetch failed:', {
url,
error: error.message,
stack: error.stack
});
return { success: false, error: friendlyMessage, originalError: error };
} finally {
if (showGlobalLoader) {
this.hideLoading();
}
if (widgetElement) {
this.hideWidgetLoading(widgetElement);
}
}
}
getActiveRequestCount() {
return this.activeRequests.size;
}
getActiveRequests() {
return Array.from(this.activeRequests.values());
}
cancelAll() {
this.activeRequests.clear();
this.hideLoading();
}
}
window.loadingManager = new LoadingManager();
if (typeof module !== 'undefined' && module.exports) {
module.exports = LoadingManager;
}

/* theme-manager.js */
class ThemeManager {
constructor() {
this.storageKey = 'pinkybot-theme-preference';
this.themeElement = document.documentElement; 
this.init();
}
init() {
const savedTheme = this.getSavedTheme();
const systemTheme = this.getSystemTheme();
const themeToApply = savedTheme || systemTheme || 'dark';
this.setTheme(themeToApply, false); 
console.log('[ThemeManager] Initialized with theme:', themeToApply);
}
getSavedTheme() {
try {
return localStorage.getItem(this.storageKey);
} catch (e) {
console.warn('[ThemeManager] localStorage unavailable:', e);
return null;
}
}
getSystemTheme() {
if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
return 'dark';
}
return 'light';
}
setTheme(theme, save = true) {
if (!['dark', 'light', 'auto'].includes(theme)) {
console.warn('[ThemeManager] Invalid theme:', theme);
return;
}
let actualTheme = theme;
if (theme === 'auto') {
actualTheme = this.getSystemTheme();
}
if (actualTheme === 'light') {
this.themeElement.classList.add('light-mode');
} else {
this.themeElement.classList.remove('light-mode');
}
if (save) {
try {
localStorage.setItem(this.storageKey, theme);
console.log('[ThemeManager] Saved theme preference:', theme);
} catch (e) {
console.warn('[ThemeManager] Failed to save theme:', e);
}
}
window.dispatchEvent(new CustomEvent('theme-changed', { 
detail: { theme, actualTheme } 
}));
}
getCurrentTheme() {
return this.themeElement.classList.contains('light-mode') ? 'light' : 'dark';
}
toggleTheme() {
const current = this.getCurrentTheme();
const next = current === 'dark' ? 'light' : 'dark';
this.setTheme(next);
return next;
}
createToggleButton() {
const button = document.createElement('button');
button.id = 'theme-toggle-button';
button.className = 'theme-toggle-btn';
button.title = 'Toggle Dark/Light Mode';
button.innerHTML = this.getCurrentTheme() === 'dark' ? '‚òÄÔ∏è' : 'üåô';
button.addEventListener('click', () => {
const newTheme = this.toggleTheme();
button.innerHTML = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
});
return button;
}
}
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => {
window.themeManager = new ThemeManager();
});
} else {
window.themeManager = new ThemeManager();
}

/* renderer.js */
console.log('[Dashboard] Initializing...');
function formatDateEST(timestamp) {
if (!timestamp) return '--:--';
const date = new Date(timestamp);
return date.toLocaleString('en-US', { 
timeZone: 'America/New_York',
month: 'short',
day: 'numeric',
hour: '2-digit',
minute: '2-digit',
second: '2-digit',
hour12: true
});
}
function formatTimeEST(timestamp) {
if (!timestamp) return '--:--';
const date = new Date(timestamp);
return date.toLocaleTimeString('en-US', { 
timeZone: 'America/New_York',
hour: '2-digit',
minute: '2-digit',
second: '2-digit',
hour12: true
});
}
let currentView = 'dashboard';
let currentMonitorView = 'heartbeat';
let activityData = {
heartbeats: [],
thinking: [],
usage: { tokens: 0, exec: 0, files: 0, responses: [] }
};
let notificationCounts = {
chat: 0,
tasks: 0,
filesystem: 0,
docs: 0,
research: 0,
code: 0,
social: 0,
business: 0
};
function updateBadgeCount(botName, count) {
notificationCounts[botName] = Math.max(0, count);
const badge = document.querySelector(`.${botName}-badge`);
if (badge) {
badge.textContent = count;
if (count > 0) {
badge.classList.remove('hidden');
} else {
badge.classList.add('hidden');
}
}
}
function clearBotBadge(botName) {
updateBadgeCount(botName, 0);
}
function incrementBadgeCount(botName, amount = 1) {
updateBadgeCount(botName, notificationCounts[botName] + amount);
}
function getTotalNotificationCount() {
return Object.values(notificationCounts).reduce((a, b) => a + b, 0);
}
window.switchToView = function(viewName) {
console.log('[Nav] Switching to view:', viewName);
document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
const targetView = document.getElementById(viewName + '-view');
if (targetView) {
if (viewId === "tasks-view" && window.tasksBotEnhanced && !window.tasksBotEnhanced.isInitialized) {
window.tasksBotEnhanced.init();
}
targetView.classList.add('active');
currentView = viewName + '-view';
}
document.querySelectorAll('.bot-button, .view-button').forEach(b => b.classList.remove('active'));
const clickedButton = document.querySelector(`[data-bot="${viewName}"], [data-view="${viewName}"]`);
if (clickedButton) {
clickedButton.classList.add('active');
}
if (notificationCounts.hasOwnProperty(viewName)) {
clearBotBadge(viewName);
}
if (typeof addActivity === 'function') {
addActivity('Navigation', `Switched to ${viewName} view`);
}
};
window.addEventListener('DOMContentLoaded', () => {
console.log('[Dashboard] DOM loaded');
initBotButtons();
initViewButtons();
initMonitorButtons();
loadActivityData();
setInterval(loadActivityData, 5000); 
setInterval(updateStats, 10000); 
});
function initBotButtons() {
document.querySelectorAll('.bot-button').forEach(btn => {
btn.addEventListener('click', (e) => {
e.preventDefault();
const bot = btn.dataset.bot;
console.log('[Nav] Switching to bot:', bot);
switchView(bot + '-view');
document.querySelectorAll('.bot-button').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
addActivity('Navigation', `Switched to ${bot} view`);
});
});
console.log('[Init] Bot buttons initialized:', document.querySelectorAll('.bot-button').length);
}
function initViewButtons() {
document.querySelectorAll('.view-button').forEach(btn => {
btn.addEventListener('click', () => {
const view = btn.dataset.view;
switchView(view + '-view');
});
});
}
function switchView(viewId) {
document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
const targetView = document.getElementById(viewId);
if (targetView) {
if (viewId === "tasks-view" && window.tasksBotEnhanced && !window.tasksBotEnhanced.isInitialized) {
window.tasksBotEnhanced.init();
}
if (viewId === "settings-view" && window.initSettingsPage) {
window.initSettingsPage();
}
targetView.classList.add('active');
currentView = viewId;
}
}
function quickAction(bot, action) {
console.log(`[Quick Action] ${bot} - ${action}`);
addActivity(bot, `Quick action: ${action}`);
setTimeout(() => {
addActivity(bot, `√¢≈ì‚Ä¶ Completed: ${action}`);
updateTaskCount();
}, 2000);
}
function addActivity(bot, message) {
const feed = document.getElementById('activity-feed');
if (!feed) return;
const item = document.createElement('div');
item.className = 'activity-item';
item.innerHTML = `
<span class="activity-time">${formatTimeEST(new Date())}</span>
<span class="activity-bot">${bot}</span>
<span class="activity-message">${message}</span>
`;
feed.insertBefore(item, feed.firstChild);
while (feed.children.length > 50) {
feed.removeChild(feed.lastChild);
}
}
function updateTaskCount() {
const countEl = document.getElementById('tasks-completed');
if (countEl) {
const current = parseInt(countEl.textContent) || 0;
countEl.textContent = current + 1;
}
const todayEl = document.getElementById('tasks-today');
if (todayEl) {
const current = parseInt(todayEl.textContent.match(/\d+/)?.[0]) || 0;
todayEl.textContent = `√∞≈∏‚Äú≈† ${current + 1} Tasks Today`;
}
}
function updateStats() {
const costEl = document.getElementById('cost-saved');
if (costEl) {
const current = parseFloat(costEl.textContent.replace('$', '')) || 0;
costEl.textContent = '$' + (current + 0.25).toFixed(2);
}
const speedEl = document.getElementById('speed-gain');
if (speedEl) {
const tasks = parseInt(document.getElementById('tasks-completed')?.textContent) || 0;
speedEl.textContent = Math.max(1, Math.floor(tasks / 10)) + 'x';
}
}
function initMonitorButtons() {
const heartbeatBtn = document.getElementById('monitor-heartbeat');
const thinkingBtn = document.getElementById('monitor-thinking');
const peakBtn = document.getElementById('monitor-peak');
if (heartbeatBtn) {
heartbeatBtn.addEventListener('click', () => switchMonitorView('heartbeat'));
}
if (thinkingBtn) {
thinkingBtn.addEventListener('click', () => switchMonitorView('thinking'));
}
if (peakBtn) {
peakBtn.addEventListener('click', () => switchMonitorView('peak'));
}
}
function switchMonitorView(view) {
currentMonitorView = view;
document.querySelectorAll('.monitor-btn').forEach(btn => btn.classList.remove('active'));
document.getElementById(`monitor-${view}`)?.classList.add('active');
document.querySelectorAll('.monitor-content').forEach(c => c.classList.remove('active'));
document.getElementById(`${view}-content`)?.classList.add('active');
renderMonitorChart(view);
}
async function loadActivityData() {
const result = await window.loadingManager.fetch('/api/activity', {}, {
errorTitle: 'Activity Data Load Failed',
silent: true 
});
if (result.success) {
const data = result.data;
const heartbeatsArray = data.heartbeats || [];
activityData = {
heartbeats: heartbeatsArray,
heartbeatCount: heartbeatsArray.length
};
updateMonitorStats();
renderMonitorChart(currentMonitorView);
renderHeaderStats();
console.log('[Monitor] Loaded activity data from /api/activity: ' + heartbeatsArray.length + ' heartbeats');
} else {
console.error('[Monitor] Failed to load activity data:', result.error);
}
}
function updateMonitorStats() {
const lastHB = activityData.heartbeats[activityData.heartbeats.length - 1];
if (lastHB) {
const lastHBEl = document.getElementById('last-heartbeat');
if (lastHBEl) {
lastHBEl.textContent = formatTimeEST(lastHB.timestamp);
}
}
const wakeupsEl = document.getElementById('total-wakeups');
if (wakeupsEl) {
wakeupsEl.textContent = activityData.heartbeats.length;
}
const tokensEl = document.getElementById('tokens-used'); if (tokensEl) tokensEl.textContent = activityData.usage.tokens.toLocaleString();
const execEl = document.getElementById('exec-calls'); if (execEl) execEl.textContent = activityData.usage.exec;
const fileEl = document.getElementById('file-ops'); if (fileEl) fileEl.textContent = activityData.usage.files;
if (activityData.usage.responses.length > 0) {
const avg = activityData.usage.responses.reduce((a,b) => a+b, 0) / activityData.usage.responses.length;
const avgEl = document.getElementById('avg-response'); if (avgEl) avgEl.textContent = Math.round(avg) + 'ms';
}
}
function renderMonitorChart(view) {
if (view === 'heartbeat') {
renderHeartbeatLog();
} else if (view === 'thinking') {
renderThinkingLog();
} else if (view === 'peak') {
renderPeakLog();
}
}
function renderHeartbeatLog() {
const logEl = document.getElementById('heartbeat-log');
if (!logEl) return;
logEl.innerHTML = '';
activityData.heartbeats.slice(-20).reverse().forEach(hb => {
const entry = document.createElement('div');
entry.className = 'activity-item';
entry.innerHTML = `
<span class="activity-time">${formatDateEST(hb.timestamp)}</span>
<span class="activity-bot">${(hb.activity || '').startsWith('Dashboard Chat:') ? 'Chat' : 'Heartbeat'}</span>
<span class="activity-message">${hb.activity || 'Check'}${hb.lagMs !== undefined ? ' - ' + hb.lagMs + 'ms lag' : ''}</span>
`;
logEl.appendChild(entry);
});
}
function renderThinkingLog() {
const logEl = document.getElementById('thinking-log');
if (!logEl) return;
logEl.innerHTML = '';
if (activityData.thinking.length === 0) {
logEl.innerHTML = '<div class="activity-item"><span class="activity-message">No thinking sessions yet...</span></div>';
return;
}
const hourCounts = {};
activityData.thinking.forEach(t => {
const hour = new Date(t.timestamp).getHours();
hourCounts[hour] = (hourCounts[hour] || 0) + 1;
});
activityData.thinking.slice(-10).reverse().forEach(think => {
const entry = document.createElement('div');
entry.className = 'activity-item';
entry.innerHTML = `
<span class="activity-time">${formatDateEST(think.timestamp)}</span>
<span class="activity-bot">Thinking</span>
<span class="activity-message">${think.task}</span>
`;
logEl.appendChild(entry);
});
const thinkEl = document.getElementById('think-sessions'); if (thinkEl) thinkEl.textContent = activityData.thinking.length;
const peakHour = Object.keys(hourCounts).reduce((a, b) => 
hourCounts[a] > hourCounts[b] ? a : b, '0');
const peakEl = document.getElementById('peak-hour'); if (peakEl) peakEl.textContent = peakHour + ':00';
}
function renderPeakLog() {
const logEl = document.getElementById('peak-log');
if (!logEl) return;
logEl.innerHTML = '';
activityData.heartbeats.slice(-10).reverse().forEach(hb => {
const entry = document.createElement('div');
entry.className = 'activity-item';
entry.innerHTML = `
<span class="activity-time">${formatTimeEST(hb.timestamp)}</span>
<span class="activity-bot">Resources</span>
<span class="activity-message">
${hb.tokens || 0} tokens, ${hb.exec || 0} exec, ${hb.lagMs || 0}ms
</span>
`;
logEl.appendChild(entry);
});
}
function downloadLogs() {
const blob = new Blob([JSON.stringify(activityData, null, 2)], 
{ type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'pinky-activity-' + Date.now() + '.json';
a.click();
URL.revokeObjectURL(url);
}
const FileSystemBot = {
async organize(path) {
console.log('[FileSystemBot] Organizing:', path);
addActivity('FileSystemBot', `Organizing: ${path}`);
return { success: true, filesOrganized: 0 };
},
async cleanup(path) {
console.log('[FileSystemBot] Cleanup:', path);
addActivity('FileSystemBot', `Cleaning up: ${path}`);
return { success: true, filesRemoved: 0 };
},
async search(query) {
console.log('[FileSystemBot] Searching for:', query);
addActivity('FileSystemBot', `Searching: ${query}`);
return { success: true, results: [] };
},
async backup(path) {
console.log('[FileSystemBot] Backing up:', path);
addActivity('FileSystemBot', `Backing up: ${path}`);
return { success: true, backupPath: '' };
}
};
function botAction(bot, action) {
console.log(`[Bot Action] ${bot} - ${action}`);
addActivity(bot, `Executing: ${action}`);
const botFeed = document.getElementById(`${bot}-activity`);
if (botFeed) {
const entry = document.createElement('div');
entry.className = 'activity-item';
entry.innerHTML = `
<span class="activity-time">${formatTimeEST(new Date())}</span>
<span class="activity-bot">${bot}</span>
<span class="activity-message">√¢≈°¬° ${action} started...</span>
`;
botFeed.insertBefore(entry, botFeed.firstChild);
}
setTimeout(() => {
addActivity(bot, `√¢≈ì‚Ä¶ Completed: ${action}`);
if (botFeed) {
const successEntry = document.createElement('div');
successEntry.className = 'activity-item';
successEntry.innerHTML = `
<span class="activity-time">${formatTimeEST(new Date())}</span>
<span class="activity-bot">${bot}</span>
<span class="activity-message">√¢≈ì‚Ä¶ ${action} completed!</span>
`;
botFeed.insertBefore(successEntry, botFeed.firstChild);
}
updateTaskCount();
updateBotStats(bot);
}, 2000);
}
function updateBotStats(bot) {
if (bot === 'docs') {
incrementStat('docs-generated');
incrementStat('docs-words', 500);
} else if (bot === 'research') {
incrementStat('research-reports');
incrementStat('research-sources', 5);
} else if (bot === 'code') {
incrementStat('code-files');
incrementStat('code-lines', 150);
} else if (bot === 'social') {
incrementStat('social-posts');
} else if (bot === 'business') {
incrementStat('business-opportunities');
}
}
function incrementStat(statId, amount = 1) {
const el = document.getElementById(statId);
if (el) {
const current = parseInt(el.textContent) || 0;
el.textContent = current + amount;
}
}
window.dashboard = {
toggleApprovals,
showApprovals: loadApprovals,
respondApproval,
clearCacheAndReload: function() { localStorage.clear(); location.reload(true); },
quickAction,
addActivity,
FileSystemBot,
switchView,
switchMonitorView,
downloadLogs,
loadActivityData,
botAction
};
console.log('[Dashboard] Ready! Use window.dashboard to access functions.');
async function renderHeaderStats() {
const container = document.getElementById('heartbeat-status-container');
if (!container) return;
const [usageResult, statsResult, tasksResult, activityResult] = await Promise.all([
window.loadingManager.fetch('/api/usage', {}, { silent: true }),
window.loadingManager.fetch('/api/tasks/stats', {}, { silent: true }),
window.loadingManager.fetch('/api/tasks', {}, { silent: true }),
window.loadingManager.fetch('/api/activity', {}, { silent: true })
]);
const usage = usageResult.success ? usageResult.data : {};
const statsResponse = statsResult.success ? statsResult.data : {};
const tasks = tasksResult.success ? tasksResult.data : [];
const activity = activityResult.success ? activityResult.data : {};
{
const tokensUsed = usage.totalTokens || 0;
const apiCost = usage.totalCost || 0;
const messages = usage.messages || 0;
const stats = statsResponse.stats || {};
const allCompleted = stats.completed || 0;
const completionRate = stats.completionRate || '0%';
const pending = stats.pending || 0;
const heartbeatsArray = activity.heartbeats || [];
const heartbeatCount = heartbeatsArray.length;
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
const tasksToday = Array.isArray(tasks) ? tasks.filter(t => {
if (t.status !== 'completed') return false;
const updated = new Date(t.updated || t.assigned);
const taskDate = new Date(updated.getFullYear(), updated.getMonth(), updated.getDate());
return taskDate.getTime() === today.getTime();
}).length : 0;
let html = '<div class="heartbeat-status">';
html += '<h3>üíì Heartbeat Status</h3>';
html += '<div class="heartbeat-grid">';
html += '<div class="heartbeat-stat"><span class="stat-label">Heartbeats</span><span class="stat-value">' + heartbeatCount + '</span></div>';
html += '<div class="heartbeat-stat"><span class="stat-label">Tasks Today</span><span class="stat-value">' + tasksToday + '</span></div>';
html += '<div class="heartbeat-stat"><span class="stat-label">Pending</span><span class="stat-value">' + pending + '</span></div>';
html += '<div class="heartbeat-stat"><span class="stat-label">Tokens Used</span><span class="stat-value">' + (tokensUsed / 1000000).toFixed(1) + 'M</span></div>';
html += '</div></div>';
container.innerHTML = html;
const tasksCompletedEl = document.getElementById("tasks-completed");
if (tasksCompletedEl) tasksCompletedEl.textContent = allCompleted;
const apiCostEl = document.getElementById("api-cost");
if (apiCostEl) apiCostEl.textContent = "$" + apiCost.toFixed(2);
const messagesEl = document.getElementById("total-messages");
if (messagesEl) messagesEl.textContent = messages.toLocaleString();
const successRateEl = document.getElementById("success-rate");
if (successRateEl) successRateEl.textContent = completionRate;
const wakeupEl = document.getElementById("total-wakeups");
if (wakeupEl) wakeupEl.textContent = heartbeatCount;
console.log('[HeaderStats] Updated: ' + heartbeatCount + ' heartbeats, ' + allCompleted + ' tasks, $' + apiCost.toFixed(2) + ' cost, ' + messages + ' messages, ' + completionRate + ' success rate');
}
}
document.addEventListener('DOMContentLoaded', function() {
renderHeaderStats(); 
setInterval(renderHeaderStats, 30000); 
});
let approvalsOpen = false;
function toggleApprovals() {
const dropdown = document.getElementById('approval-dropdown');
approvalsOpen = !approvalsOpen;
dropdown.classList.toggle('hidden', !approvalsOpen);
if (approvalsOpen) loadApprovals();
}
async function loadApprovals() {
const result = await window.loadingManager.fetch('/api/approvals', {}, {
errorTitle: 'Failed to Load Approvals',
silent: true
});
if (!result.success) {
console.error('[Approvals] Load failed:', result.error);
return;
}
const data = result.data;
const badge = document.getElementById('approval-badge');
const list = document.getElementById('approval-list');
const count = data.pending.length;
badge.textContent = count;
badge.classList.toggle('hidden', count === 0);
if (count === 0) {
list.innerHTML = '<p class="no-approvals">No pending approvals</p>';
return;
}
list.innerHTML = data.pending.map(req => `
<div class="approval-item" data-id="${req.id}">
<h4>üìã ${req.title}</h4>
<div class="file">üìÅ ${req.file || 'N/A'}</div>
<div class="description">${req.description || ''}</div>
<textarea placeholder="Add instructions for Pinky (optional)..." id="instructions-${req.id}"></textarea>
<div class="approval-buttons">
<button class="btn-approve" onclick="respondApproval('${req.id}', true)">‚úÖ Approve</button>
<button class="btn-deny" onclick="respondApproval('${req.id}', false)">‚ùå Deny</button>
</div>
<div class="approval-time">Requested: ${formatDateEST(req.createdAt)}</div>
</div>
`).join('');
}
async function respondApproval(id, approved) {
const instructions = document.getElementById('instructions-' + id)?.value || '';
const result = await window.loadingManager.fetch('/api/approvals/' + id + '/respond', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ approved, instructions })
}, {
loadingMessage: approved ? 'Approving...' : 'Denying...',
errorTitle: 'Approval Response Failed'
});
if (result.success && result.data.success) {
loadApprovals();
window.loadingManager.success(
approved ? 'Approved!' : 'Denied',
approved ? 'Pinky can proceed with the task.' : 'Request has been denied.'
);
}
}
setInterval(async () => {
const result = await window.loadingManager.fetch('/api/approvals', {}, { silent: true });
if (result.success) {
const data = result.data;
const badge = document.getElementById('approval-badge');
if (badge) {
badge.textContent = data.pending.length;
badge.classList.toggle('hidden', data.pending.length === 0);
}
}
}, 30000);
document.addEventListener('DOMContentLoaded', () => {
setTimeout(loadApprovals, 1000);
});

/* performance-loader.js */
class PerformanceLoader {
constructor() {
this.loadedModules = new Set();
this.pendingLoads = new Map();
this.criticalResources = [
'styles.css',
'mobile-responsive.css',
'renderer.js',
'theme-manager.js',
'loading-manager.js'
];
this.metrics = {
startTime: performance.now(),
deferredModules: 0,
lazyLoadedResources: 0
};
}
loadCSS(href, critical = false) {
if (this.loadedModules.has(href)) {
return Promise.resolve();
}
return new Promise((resolve, reject) => {
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = href;
if (!critical) {
link.media = 'print';
link.onload = () => {
link.media = 'all';
this.loadedModules.add(href);
resolve();
};
} else {
link.onload = () => {
this.loadedModules.add(href);
resolve();
};
}
link.onerror = reject;
document.head.appendChild(link);
});
}
loadJS(src, defer = true) {
if (this.loadedModules.has(src)) {
return Promise.resolve();
}
if (this.pendingLoads.has(src)) {
return this.pendingLoads.get(src);
}
const promise = new Promise((resolve, reject) => {
const script = document.createElement('script');
script.src = src;
script.async = true;
if (defer) script.defer = true;
script.onload = () => {
this.loadedModules.add(src);
this.pendingLoads.delete(src);
this.metrics.lazyLoadedResources++;
resolve();
};
script.onerror = () => {
this.pendingLoads.delete(src);
reject(new Error(`Failed to load: ${src}`));
};
document.body.appendChild(script);
});
this.pendingLoads.set(src, promise);
return promise;
}
async loadBotModule(botName) {
const moduleMap = {
'tasks': ['tasks-bot-enhanced.js', 'task-analytics.js', 'task-history-chart.js', 'task-statistics.js'],
'chat': ['pinky-chat.js', 'pinky-chat.css'],
'filesystem': ['filesystem-bot-llm.js'],
'social': ['social-bot-ui.js', 'social-api-connectors.js', 'wordpress-page-maker.js'],
'settings': ['settings-page.js', 'settings.css'],
'analytics': ['analytics-advanced.js', 'token-allocation-widget.js'],
'health': ['system-health-widget.js', 'system-monitor-ui.js'],
'export': ['export-package.js', 'export-package-ui.js', 'export-package.css']
};
const modules = moduleMap[botName] || [];
const loadPromises = modules.map(module => {
if (module.endsWith('.css')) {
return this.loadCSS(module);
} else {
return this.loadJS(module);
}
});
await Promise.all(loadPromises);
console.log(`‚úÖ Loaded ${botName} modules:`, modules.length);
}
lazyLoadWidget(widgetElement, jsFiles = [], cssFiles = []) {
const observer = new IntersectionObserver(async (entries) => {
for (const entry of entries) {
if (entry.isIntersecting) {
const promises = [
...jsFiles.map(f => this.loadJS(f)),
...cssFiles.map(f => this.loadCSS(f))
];
try {
await Promise.all(promises);
widgetElement.classList.add('loaded');
} catch (err) {
console.error('Widget load failed:', err);
}
observer.unobserve(widgetElement);
}
}
}, { rootMargin: '50px' });
observer.observe(widgetElement);
}
deferNonCriticalCSS() {
const nonCriticalCSS = [
'task-statistics.css',
'task-history-chart.css',
'task-timer.css',
'settings.css',
'export-package.css',
'system-health-widget.css',
'changelog-widget.css',
'error-page-pinky.css',
'notification-sounds.css',
'task-analytics.css',
'tooltip-system.css',
'about-page.css',
'wordpress-page-maker.css',
'approval-queue.css',
'token-allocation-widget.css',
'task-search-filter.css',
'keyboard-shortcuts.css',
'file-attachment-module.css'
];
nonCriticalCSS.forEach(css => this.loadCSS(css, false));
this.metrics.deferredModules += nonCriticalCSS.length;
}
deferNonCriticalJS() {
const nonCriticalJS = [
'file-attachment-manager.js',
'file-attachment-module.js',
'task-timer.js',
'task-queue-integration.js',
'metrics-persistence.js',
'health-dashboard.js',
'changelog-widget.js',
'loading-animation.js',
'error-page-pinky.js',
'notification-sounds.js',
'tooltip-system.js',
'about-page.js',
'keyboard-shortcuts.js',
'company-manager.js',
'wordpress-bot-framework.js',
'research-bot-framework.js'
];
requestIdleCallback(() => {
nonCriticalJS.forEach(js => {
this.loadJS(js, true).catch(err => {
console.warn(`Deferred load failed: ${js}`, err);
});
});
this.metrics.deferredModules += nonCriticalJS.length;
}, { timeout: 2000 });
}
preloadCriticalResources() {
const critical = [
{ href: 'styles.css', as: 'style' },
{ href: 'mobile-responsive.css', as: 'style' },
{ href: 'renderer.js', as: 'script' }
];
critical.forEach(({ href, as }) => {
const link = document.createElement('link');
link.rel = 'preload';
link.href = href;
link.as = as;
document.head.appendChild(link);
});
}
getMetrics() {
const loadTime = performance.now() - this.metrics.startTime;
return {
loadTime: `${(loadTime / 1000).toFixed(2)}s`,
deferredModules: this.metrics.deferredModules,
lazyLoadedResources: this.metrics.lazyLoadedResources,
totalModulesLoaded: this.loadedModules.size,
navigationTiming: performance.getEntriesByType('navigation')[0]
};
}
init() {
console.log('‚ö° PerformanceLoader: Initializing...');
this.preloadCriticalResources();
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => {
this.deferNonCriticalCSS();
this.deferNonCriticalJS();
});
} else {
this.deferNonCriticalCSS();
this.deferNonCriticalJS();
}
setTimeout(() => {
const metrics = this.getMetrics();
console.log('‚ö° Performance Metrics:', metrics);
if (parseFloat(metrics.loadTime) < 3.0) {
console.log('‚úÖ GOAL MET: Dashboard loaded in under 3 seconds!');
} else {
console.warn('‚ö†Ô∏è GOAL MISSED: Dashboard took longer than 3 seconds');
}
}, 3000);
}
}
window.performanceLoader = new PerformanceLoader();
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => {
window.performanceLoader.init();
});
} else {
window.performanceLoader.init();
}
